linq-cpp
========

LINQ for C++11 done right

introduction
------------

The `IEnumerable<T>` interface and associated LINQ extension methods provided by the .NET framework enable .NET programmers to write concise, fluent, and composable query expressions. For anyone familiar with these tools, their incredible utility shouldn't need explaining. linq-cpp brings equivalent functionality to the C++11 environment.

If you are a programmer not familiar with .NET's `IEnumerable<T>` and LINQ, the rest of this section aims to quickly give you a basic understanding of what this library provides. (TODO) 

classes
=======
    class TEnumerable<T>
        std::shared_ptr<TEnumerator<T>> GetEnumerator()
        
    class TEnumerator<T>
        bool MoveNext()
        T Current()

methods
=======
`static Enumerable class`
------------
- `TEnumerable<T> FromRange(TRange& range)`
 - Same as `FromRange(range.begin(), range.end())`
- `TEnumerable<T> FromRange(TIter begin, TIter end)`
 - Construct an `Enumerable` from STL iterators
- `TEnumerable<T> Factory(const TFactory& factory)`
 - `TFactory = TEnumerable<T>()`
 - Repeated calls to `factory` argument each create an enumerable that can only be enumerated once
 - Result is Enumerable that can be enumerated as many times as desired
- `TEnumerable<T> Repeat(T x)`
 - Represents an infinite sequence of which every element is `x`
- `TEnumerable<T> Empty()`
 - Represents an empty sequence
- `TEnumerable<T> Return(T x)`
 - Represents a sequence that contains a single element `x`
- `TEnumerable<T> Generate(const TFactory& factory)`
 - Repeated calls to factory generate elements of sequence
- `TEnumerable<T> Sequence(T start, const TPredicate& predicate, const TNext& next)`
- `TEnumerable<T> Sequence(T start, const TNext& next)`
- `TEnumerable<T> Sequence(T start)`
- `TEnumerable<T> Sequence()`
 - `TPredicate = bool()`
 - `TNext = T(T)`
 - The sequence generated by a typical `for` loop
- `TEnumerable<T> Range(T start, T count)`
 - The sequence `start, start+1, ..., start+count`
- `TEnumerable<T> Concat(TEnumerable<T> first, TEnumerable<T> second)`
 - The sequence formed by `first` followed by `second`
- `TEnumerable<TResult> Zip(TEnumerable<T1> first, TEnumerable<T2> second, const TSelector& selector)`
 - `TSelector = TResult(T1, T2)`
 - Merges two sequences by using the specified `selector` function
